<?php include_once("header.php");
session_destroy();
?>

    <div class="mypadding" style="text-align: justify">

        <div class="h1" style="text-align: center">
            Встановлення та налаштування
        </div>
        <div>
            <div class="h2" style="text-align: center">
                Вбудований web-сервер
            </div>
            <div>
                <p>
                    Ви можете почати вивчення PHP без необхідності у встановленні та конфігурації повноцінного
                    веб-сервера
                    (Необхідний PHP 5.4 або новіше). Для запуску сервера, запустіть наступну команду із вашого терміналу
                    в корені вашого проекту:
                </p>
                    <code>
                        php -S localhost:8000
                    </code>

            </div>

            <div class="h2" style="text-align: center">
                Встановлення на Mac
            </div>
            <div>
                <p>
                    OSX іде разом з вбудованим PHP, та зазвичай його версія трохи відстає від останньої стабільної.
                    Lion постачається з PHP 5.3.6 а Mountain Lion з 5.3.10.
                </p>
                <p>
                    Ви можете обновити PHP на OSX через кілька менеджерів пакетів, з рекомендованим php-osx by Liip.
                </p>
                <p>>
                    Інший варіант скомпілювати самостійно. В цьому випадку ви повинні впевнитися,
                    що у вас встановлений Xcode, або його аналог від Apple “Інструменти командного рядка для Xcode”,
                    їх можна скачати з Apple’s Mac Developer Center.
                </p>
                <p>
                    Для повного набору “все-в-одному”, включаючи PHP, веб-сервер Apache, та базу даних MySQL з
                    хорошим графічним інтерфейсом, спробуйте MAMP.
                </p>
            </div>

            <div class="h2" style="text-align: center">
                Встановлення у Windows
            </div>
            <div>
                <p>
                    PHP для Windows доступний в кількох видах. Ви можете скачати бінарні файли і до недавнього часу
                    могли використовувати встановлювач ‘.msi’. Встановлювач більше не підтримується починаючи з
                    версії PHP 5.3.0.
                </p>
                <p>
                    Для навчання та локальної розробки ви можете використовувати вбудований вебсервер із PHP 5.4
                    отож вам не потрібно хвилюватись за його конфугурування. Якщо ви хочете використовувати пакет
                    “все-в-одному” котрий включає вебсервер та MySQL також тоді інструменти такі як
                    Web Platform Installer,
                    XAMPP та WAMP допоможуть вам швидко отримати готове середовище для розробки на Windows.
                    Тим не менше, ці інструменти мають певні відмінності від production тож не забувайте про
                    ці особливості,
                    коли ви працюєте в Windows, а розгортання відбувається в Linux.
                </p>
                <p>
                    Якщо вам потрібно розгорнути вашу систему на Windows тоді IIS7 забезпечить вам найкращу стабільність
                    та продуктивність. Ви можете використовувати phpmanager (GUI плагин для IIS7) щоб спростити
                    конфігурування та керування PHP. IIS7 постачається з вбудованим та готовим до використання FastCGI,
                    вам лише потрібно сконфігурувати PHP як обробник. Для підтримки та додаткових ресурсів існує
                    спеціальний розділ на iis.net для PHP.
                </p>
                <p>
                    Зазвичай, запуск вашої програми в різних середовищах при розробці та її безпосередньому використанні
                    може призвести до дивних помилок, що появлятимуться коли ви запускаєте програму.Якщо ви розробляєте
                    програми на Windows для використання під Linux, або якусь іншу ОС (не Windows).
                </p>
                <p>
                    Тоді ви повинні розглянути використання віртуальної машини. Це звучить складно, та з допомогою
                    Vagrant
                    ви можете встановити прості обгортки, згодом використовуючи Puppet або Chef ви можете створювати ці
                    блоки та ділитися ними з своїми колегами, щоб впевнитися, що ви працюєте над одним і тим же.
                    Більше про це згодом.
                </p>
            </div>
        </div>

        <div class="h1" style="text-align: center">
            Керівництво з написання коду
        </div>
        <div>
            <p>
                Світ PHP великий та різноманітний, він складається з незліченних бібліотек, фреймворків та компонентів.
                Це спільне для PHP розробників, можливість обирати кілька з них та обєднувати в одному проекті.
                Важливо, щоб PHP код притримувався, на стільки, на скільки можливо, загальної стилістики коду,
                щоб полегшити розробникам змішування та поєднання різноманітних бібліотек для їх проектів.
            </p>
            <p>
                Група Взаємодії Фреймворків (раніше відома, як ‘Група PHP Стандартів’) запропонувала та схвалила
                серію рекомендацій по стилю кодування, відомих як PSR-0, PSR-1 і PSR-2. Не дозволяйте цим смішним
                іменам спантеличити вас, ці рекомендації всього лиш набір правил, котрі деякі проекти, такі як Drupal,
                Zend, CakePHP, phpBB, AWS SDK, FuelPHP, Lithium, та інші починають впроваджувати. Ви можете почати
                використовувати їх для своїх власних проектів або продовжувати використовувати ваш власний стиль.
            </p>
            <p>
                В ідеалі ви повинні писати код, котрий притримується одного або кількох із цих стандартів,
                щоб інші розробники могли легко читати і працювати з вашим кодом. Всі вони добавляють вимоги до
                попередньої рекомендації, отож використання PSR-1 вимагає PSR-0, але не вимагає PSR-2.
            </p>
            <p>
                <a href="psr0.php">Read about PSR-0</a>
            </p>
            <p>
                <a href="psr1.php">Read about PSR-1</a>
            </p>
            <p>
                <a href="psr2.php">Read about PSR-2</a>
            </p>
            <p>
                <a href="">Read about PSR-4</a>
            </p>
            <p>
                <a href="">Read about PEAR Coding</a>
            </p>
            <p>
                <a href="">Read about Zend Coding Standards</a>
            </p>
            <p>
                <a href="">Read about Symfony Coding Standards</a>
            </p>
            <p>
                Ви можете використовувати PHP_CodeSniffer, для перевірки коду на відповідність цим рекомендаціям,
                додатки до текстових редакторів; Sublime Text 2 або подібні для отримання допомоги у реальному часі.
            </p>
            <p>
                Використовуйте Налагоджувач стандартів кодування PHP Фаб’єна Потенсьєра для автоматичної зміни
                синтаксису вашого коду, щоб він відповідав цим стандартам, це позбавить вас від виправлення
                кожної проблеми вручну.
            </p>
            <p>
                Слід використовувати англійську для іменування. Коментарі можуть бути на будь-якій мові, зручній для
                усіх, хто працює з кодом або буде працювати у майбутньому.
            </p>
        </div>

        <div class="h1" style="text-align: center">
            Особливості мови
        </div>
        <div>

            <div class="h2" style="text-align: center">
                Парадигми програмування
            </div>
            <div>
                <p>
                    PHP гнучка та динамічна мова, котра підтримує різноманітя технік програмування.
                    Вона значно розвинулася з роками, зокрема додавши солідну об’єктно-орієнтовну
                    модель в PHP 5.0 (2004), анонімні функції та просторові імена в PHP 5.3 (2009),
                    а також трейти в PHP 5.4 (2012).
                </p>

                <div class="h3" style="text-align: center">
                    Об’єктно-орієнтоване програмування
                </div>
                <div>
                    <p>
                        PHP має повний набір особливостей об’єктно-орієнтованого програмування,
                        включаючи підтримку класів, абстрактних класів, інтерфейсів, наслідування,
                        конструкторів, клонування, винятків та ін.
                    </p>
                    <ul>
                        <li>
                            <a href="http://www.php.net/manual/en/language.oop5.php">
                                Прочитати про об’єктно орієнтований PHP
                            </a>
                        </li>
                        <li>
                            <a href="http://www.php.net/traits">
                                Прочитати про трейти
                            </a>
                        </li>
                    </ul>
                </div>

                <div class="h3" style="text-align: center">
                    Функціональне програмування
                </div>
                <div>
                    <p>
                        PHP підтримує функції першого класу, це означає, що функція може бути призначена змінній.
                        Обидві, створені користувачем та вбудовані функції можуть посилатися на змінну та
                        викликатися динамічно. Функції можуть бути передані як аргументи іншим функціям
                        (ця особливість називається функцією вищого порядку),
                        а також функція може повертати інші функції.
                    </p>
                    <p>
                        Рекурсія - особливіть, котра дозволяє функції викликати саму себе, це підтримується мовою,
                        та більша частина PHP коду фокусується на ітерації.
                    </p>
                    <p>
                        Нові анонімні функції (з підтримкою для замикань) присутні від PHP 5.3 (2009
                    </p>
                    <p>
                        PHP 5.4 добавив нову можливість зв’язувати замикання з областю видимості об’єкта,
                        а також вдосконалено підтримку callables, так що вони можуть бути використані
                        нарівні з анонімними функціями практично у всіх випадках.
                    </p>
                    <ul>
                        <li>
                            Продовжити читання
                            <a href="http://iflista.github.io/pages/Functional-Programming.html">
                                Функціональне програмування в PHP
                            </a>
                        </li>
                        <li>
                            <a href="http://www.php.net/manual/en/functions.anonymous.php">
                                Читати про анонімні функції
                            </a>
                        </li>
                        <li>
                            <a href="http://php.net/manual/en/class.closure.php">
                                Читати про клас замикання
                            </a>
                        </li>
                        <li>
                            <a href="https://wiki.php.net/rfc/closures">
                                Більше інформації в Closures RFC
                            </a>
                        </li>
                        <li>
                            <a href="http://php.net/manual/en/language.types.callable.php">
                                Читати про Callables
                            </a>
                        </li>
                        <li>
                            <a href="http://php.net/manual/en/function.call-user-func-array.php">
                                Читати про функції динамічного виклику з <code>call_user_func_array</code>
                            </a>
                        </li>
                    </ul>
                </div>

                <div class="h3" style="text-align: center">
                    Мета програмування
                </div>
                <div>
                    <p>
                        PHP підтримує різноманітні форми мета програмування через такі механізми як
                        Reflection API та Magic Methods. Доступно багато Magic Methods, таких як <code>__get()</code>,
                        <code>__set()</code>, <code>__clone()</code>, <code>__toString()</code>,
                        <code>__invoke()</code>, та ін.
                        що дозволяють розробникам змінювати поведінку класу. Розробники Ruby часто говорять,
                        що PHP бракує method_missing, та він доступний як <code>__call()</code> і
                        <code>__callStatic()</code>.
                    </p>
                    <ul>
                        <li>
                            <a href="http://php.net/manual/en/language.oop5.magic.php">
                                Читати про Magic Methods
                            </a>
                        </li>
                        <li>
                            <a href="http://www.php.net/manual/en/intro.reflection.php">
                                Читати про Reflection
                            </a>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="h2" style="text-align: center">
                Простори імен
            </div>
            <div>
                <p>
                    Як було сказано вище, PHP спільнота складається з багатьох розробників, котрі створюють дуже
                    багато коду. Це означає, що одна бібліотека PHP, може мати таку ж назву класу, як і інша.
                    Коли обидві бібліотеки використовуються в одному просторі імен, вони стикаються і
                    викликають проблеми.
                </p>
                <p>
                    <i>Простори імен</i> вирішують цю проблему. Як описано в документації PHP, простори імен,
                    можна порівняти з папками операційної системи, котрі являються <i>просторами імен</i> файлів;
                    два файли з однаковими іменами можуть співіснувати в різних директоріях.
                    Подібно цьому, два PHP класи з однаковими назвами можуть співіснувати в різних просторах імен PHP.
                </p>
                <p>
                    Це важливо для вас, добавляти ваш код в простори імен, так щоб він міг використовуватися
                    іншими розробниками, без страху зіткнення з іншими бібліотеками.
                </p>
                <p>
                    Один з рекомендованих способів використання просторів імен описаний в
                    <a href="psr0.php">
                        PSR-0
                    </a>,
                    котрий призваний забезпечити стандартну домовленість файлів, класів та просторів імен,
                    щоб дозволити файлів для забезпечення plug-and-play коду.
                </p>
                <ul>
                    <li>
                        <a href="http://php.net/manual/en/language.namespaces.php">
                            Читати про простори імен
                        </a>
                    </li>
                    <li>
                        <a href="psr0.php">
                            Читати про PSR-0
                        </a>
                    </li>
                </ul>
            </div>

            <div class="h2" style="text-align: center">
                Стандартна бібліотека PHP
            </div>
            <div>
                <p>
                    Стандартна бібліотека PHP (SPL) постачається з PHP та надає набір класів та інтерфейсів.
                    Вона складається в основному з часто використовуваних класів структури даних
                    (stack, queue, heap, та ін.) та ітераторів, котрі можуть пройти через ці структури
                    даних чи через ваші власні класи, котрі реалізують інтерфейси SPL.
                </p>
                <ul>
                    <li>
                        <a href="http://php.net/manual/en/book.spl.php">
                            Читати про SPL
                        </a>
                    </li>
                </ul>
            </div>

            <div class="h2" style="text-align: center">
                Інтерфейс командної строки
            </div>
            <div>
                <p>
                    PHP був створений в основному для написання веб додатків, та він також корисний для написання
                    скриптів інтерфейсу командної строки (CLI). PHP програми для командної строки можуть
                    допомогти вам автоматизувати спільні задачі, такі як тестування, розгортання,
                    та адміністрування додатку.
                </p>
                <p>
                    CLI PHP програми дуже потужні, через те, що ви можете використовувати код вашого додатку напряму,
                    без потреби в створенні і забезпеченні безпеки веб-інтерфейсу (GUI) для нього.
                    Тільки впевніться, що ваші CLI PHP скріпти знаходяться в корені вашого веб-серверу.
                </p>
                <p>
                    Спробуйте запустити PHP з консолі:
                </p>
                <pre>
                    > php -i
                </pre>
                <p>
                    Опція <code>-i</code> відобразить вашу PHP конфігурацію, схоже з функцією
                    <a href="http://php.net/manual/en/function.phpinfo.php">
                        phpinfo
                    </a>.
                </p>
                <p>
                    Опція <code>-a</code> забезпечує інтерактивну оболонку, схожу з IRB ruby або інтерактивною
                    оболонкою python. Також є цілий ряд інших корисних
                    <a href="http://www.php.net/manual/en/features.commandline.options.php">
                        опцій командної строки
                    </a>.
                </p>
                <p>
                    Давайте напишемо просту “Hello, $name” CLI програму. Щоб це зробити, створіть
                    файл з іменем <code>hello.php</code>, як показано нижче.
                </p>
                <code>
                    &lt;?php<br>
                    if($argc != 2) {<br>
                        echo "Usage: php hello.php [name].\n";<br>
                        exit(1);<br>
                    }<br>
                    $name = $argv[1];<br>
                    echo "Hello, $name\n";
                </code>
                <p>
                    PHP встановлює дві спеціальні змінні, котрі базуються на аргументах, з якими запущений ваш скріпт.
                    <a href="http://php.net/manual/en/reserved.variables.argc.php">$argc</a> - це змінна з числовим
                    значенням, що містить <i>count</i> аргументів та
                    <a href="http://php.net/manual/en/reserved.variables.argv.php">$argv</a> - це масив,
                    що містить значення кожного аргумента. Перший аргумент - завжди імя файлу вашого PHP скріпта,
                    в цьому випадку це <code>hello.php</code>.
                </p>
                <p>
                    Вираз <code>exit()</code> використовується з не нульовим числом, щоб дати оболонці зрозуміти,
                    що команда не вдалася. Часто використовувані коди завершення можна знайти
                    <a href="http://www.gsp.com/cgi-bin/man.cgi?section=3&topic=sysexits">тут</a>.
                </p>
                <p>
                    Щоб запустити наш скрипт із командної строки:
                </p>
                <pre>
                    > php hello.php
                    Usage: php hello.php [name]
                    > php hello.php world
                    Hello, world
                </pre>
                <ul>
                    <li>
                        <a href="http://php.net/manual/en/features.commandline.php">
                            Читати про запуск PHP з командної строки
                        </a>
                    </li>
                    <li>
                        <a href="http://www.php.net/manual/en/install.windows.commandline.php">
                            Читати про налаштування Windows для запуску PHP з командної строки
                        </a>
                    </li>
                </ul>
            </div>

        </div>

        <div class="h1" style="text-align: center">
            Управління залежностями
        </div>
        <div>
            <p>
                Є багато PHP бібліотек, фреймворків та компонентів на вибір. Ваш проект буде, швидше за все,
                використовувати декотрі з них - це і є залежності проекту. Навіть якщо ви управляли ними вручну,
                вам все одно потрібно було турбуватися про автозавантажувачі. Більше цього не потрібно.
            </p>
            <p>
                Зараз існує дві основні системи управління пакетами для PHP - Composer і PEAR.
                Котра з них підходить вам? Відповідь - обидві.
            </p>
            <ul>
                <li>
                    Використовуйте <b>Composer</b> коли управляєте залежностями для одного проекту.
                </li>
                <li>
                    Використовуйте <b>PEAR</b> коли управляєте залежностями для PHP в цілому у вашій системі.
                </li>
            </ul>
            <p>
                В загальному, пакети Composer будуть доступні тільки у проектах, котрі ви явно вкажете,
                тоді як пакети PEAR будуть доступні для всіх ваших PHP проектів. На перший погляд,
                PEAR може здатися більш простим підходом, але є певні переваги в використанні підходу
                проект-до-проекту для залежностей.
            </p>

            <div class="h2" style="text-align: center">
                Composer і Packagist
            </div>
            <div>
                <p>
                    Composer це <b>прекрасний</b> менеджер залежностей для PHP. Вкажіть перелік залежностей вашого
                    проекту в файлі <code>composer.json</code> і після кількох простих команд,
                    Composer автоматично завантажить залежності вашого проекту і встановить автозавантаження для вас.
                </p>
                <p>
                    Вже існує багато PHP бібліотек, котрі сумісні з Composer, готових до використання у вашому проекті.
                    Перелік цих “пакетів” є на <a href="http://packagist.org/">Packagist</a>,
                    офіційному репозиторію для Composer сумісних PHP бібліотек.
                </p>

                <div class="h3" style="text-align: center">
                    Як встановити Composer
                </div>
                <div>
                    <p>
                        Ви можете встановити Composer локально (в вашій теперішній робочій директорії;
                        хоча це більше не рекомендується) або глобально (напр. /usr/local/bin).
                        Припустимо ви хочете встановити Composer локально. З кореневої директорії
                        вашого проекту виконайте:
                    </p>
                    <pre>
                        curl -s http://getcomposer.org/installer | php
                    </pre>
                    <p>
                        Це завантажить <code>composer.phar</code> (двійковий PHP архів). Ви можете запустити
                        його через <code>php</code> для управління залежностями вашого проекту.
                        <b>Зверніть увагу:</b> Якщо ви завантажите код напряму в ваш інтерпретатор, будь ласка,
                        спочатку перечитайте його онлайн, для підтвердження його безпеки.
                    </p>
                </div>

                <div class="h3" style="text-align: center">
                    Як встановити Composer (вручну)
                </div>
                <div>
                    <p>
                        Встановлення Composer вручну - прогресивна техніка; проте, існують різні причини,
                        чому розробник може надати перевагу цьому методу над використанням інтерактивного встановлення.
                        Інтерактивне встановлення перевіряє ваше встановлення PHP, щоб впевнитися, що:
                    </p>
                    <ul>
                        <li>
                            використовується достатня версія PHP
                        </li>
                        <li>
                            файли <code>.phar</code> можуть бути виконані коректно
                        </li>
                        <li>
                            Достатні визначені права доступу до каталогу
                        </li>
                        <li>
                            певні проблемні розшинення не завантажені
                        </li>
                        <li>
                            певні налаштування php.ini встановлені
                        </li>
                    </ul>
                    <p>
                        Так як ручне встановлення не виконує жодну з цих перевірок, ви повинні вирішити,
                        чи варто йти на такий компроміс. Нижче описано, як отримати Composer вручну:
                    </p>
                    <pre>
                        curl -s http://getcomposer.org/composer.phar -o $HOME/local/bin/composer
                        chmod +x $HOME/local/bin/composer
                    </pre>
                    <p>
                        Шлях <code>$HOME/local/bin</code> (або вибрана вами директорія) повинні знаходитися
                        у вашій змінній оточення <code>$PATH</code>. Результатом буде доступність команди
                        <b>composer</b>.
                    </p>
                    <p>
                        Коли ви прочитаєте документацію до пункту, котрий стверджує,
                        що потрібно запускати Composer як <code>php composer.phar install</code>,
                        ви можете замінити цю команду як:
                    </p>
                    <pre>
                        composer install
                    </pre>
                </div>

                <div class="h3" style="text-align: center">
                    Як визначити і встановити залежності
                </div>
                <div>
                    <p>
                        Спочатку створіть файл <code>composer.json</code> в тій же директорії, що і
                        <code>composer.phar</code>. Ось приклад переліку для
                        <a href="http://twig.sensiolabs.org/">Twig</a> в якості залежності проекту.
                    </p>
                    <pre>
                        {
                            "require": {
                                "twig/twig": "1.8.*"
                            }
                        }
                    </pre>
                    <p>
                        Далі запустіть цю команду з кореневої директорії вашого проекту.
                    </p>
                    <pre>
                        php composer.phar install
                    </pre>
                    <p>
                        Це завантажить та встановить залежності проекту в директорію vendors/.
                        Далі добавте цю лінію в основний PHP файл вашого додатку;
                        це вкаже PHP використовувати автозавантажувач Composer для залежностей вашого проекту.
                    </p>
                    <code>
                        &lt;?php<br>
                        require 'vendor/autoload.php';
                    </code>
                    <p>
                        Тепер ви можете використовувати залежносі вашого проекту і вони будуть автоматично
                        завантажуватися по вимозі.
                    </p>
                    <ul>
                        <li>
                            <a href="http://getcomposer.org/doc/00-intro.md">
                                Читати про Composer
                            </a>
                        </li>
                    </ul>
                </div>

            </div>

            <div class="h2" style="text-align: center">
                PEAR
            </div>
            <div>
                <p>
                    Інший ветеран пакетних менеджерів, яким насолоджуються багато PHP розробників це
                    <a href="http://pear.php.net/">PEAR</a>.
                    Він поводиться практично таким же чином і також заслуговує розгляду для ваших проектів.
                    <a href="http://pear.php.net/">Читати про PEAR</a>.
                </p>
            </div>

        </div>

        <div class="h1" style="text-align: center">
            Практики написання коду
        </div>
        <div>
            <div class="h2" style="text-align: center">
                Винятки
            </div>
            <div>
                <p>
                    Винятки являються стандартною частиною найбільш популярних мов програмування, та вони є часто
                    обділені увагою розробниками PHP. Мови, такі як Ruby, надзвичайно детально обробляють Винятки,
                    тому коли щось йде не так, наприклад HTTP запит не вдається, або запит до бази даних відбувається
                    неправильно, або навіть якщо зображення не може знайтися, Ruby (або gems, котрі використовуються)
                    видадуть виняток на екран, що зразу дозволить зрозуміти, де помилка.
                </p>
                <p>
                    PHP сам по собі, досить слабкий в цьому і виклик <code>file_get_contents()</code> зазвичай
                    видасть вам тільки <code>FALSE</code> та попередження. Багато старіших PHP фреймворків,
                    як CodeIgniter, просто повернуть false, добавлять повідомлення у їх власний журнал та можливо
                    дадуть вам можливість використовувати метод <code>$this->upload->get_error()</code>, щоб глянути,
                    що пішло не так. Проблема в тому, що ви повинні шукати помилку і перевіряти документацію,
                    щоб зрозуміти, який помилковий метод може бути в цьому класі, замість того,
                    щоб зробити все це очевидним.
                </p>
                <p>
                    Ще одна проблема, коли класи автоматично видають помилку на екран і закривають процес.
                    Коли ви робите подібне, ви не даєте можливості другому розробнику динамічно обробити цю помилку.
                    Винятки повинні бути викинуті, щоб дати розробнику знати про помилку,
                    щоб він міг вибрати як її вирішити. Наприклад:
                </p>
                <code>
                    &lt;?php<br>
                    $email = new Fuel\Email;<br>
                    $email->subject('My Subject');<br>
                    $email->body('How the heck are you?');<br>
                    $email->to('guy@example.com', 'Some Guy');<br>
                    <br>
                    try<br>
                    {<br>
                        $email->send();<br>
                    }<br>
                    catch(Fuel\Email\ValidationFailedException $e)<br>
                    {<br>
                        // Валідація не вдалася<br>
                    }<br>
                    catch(Fuel\Email\SendingFailedException $e)<br>
                    {<br>
                        // Драйвер не може відправити повідомлення<br>
                    }
                </code>

                <div class="h3" style="text-align: center">
                    SPL Винятки
                </div>
                <div>
                    <p>
                        Виняток за замовчуванням не має значення і найбільш поширено надавати значення встановлюючи
                        його назву:
                    </p>
                    <pre>
                    &lt;?php
                    class ValidationException extends Exception {}
                </pre>
                    <p>
                        Це означає, що ви можете добавити кілька блоків відлову і обробки різних винятків по різному.
                        Це може призвести до створення <i>багатьох</i> визначених винятків, деякі з котрих можна було б
                        уникнути, використовуючи винятки SPL, що надаються
                        <a href="http://iflista.github.io/#standard_php_library">розшиненням SPL</a>.
                    </p>
                    <p>
                        Якщо наприклад ви використовуєте магічний метод <code>__call()</code> та був запит на невірний
                        метод, тоді замість видачі стандартного невизначеного винятку, чи створення окремого винятку
                        для цього ви можете просто <code>throw new BadFunctionCallException</code>;
                    </p>
                    <ul>
                        <li>
                            <a href="http://php.net/manual/en/language.exceptions.php">
                                Читати про винятки Exceptions
                            </a>
                        </li>
                        <li>
                            <a href="http://php.net/manual/en/spl.exceptions.php">
                                Читати про SPL Exceptions
                            </a>
                        </li>
                        <li>
                            <a href="http://www.brandonsavage.net/exceptional-php-nesting-exceptions-in-php/">
                                Вкладені винятки в PHP
                            </a>
                        </li>
                        <li>
                            <a href="http://ralphschindler.com/2010/09/15/exception-best-practices-in-php-5-3">
                                Кращі практики винятків в PHP 5.3
                            </a>
                        </li>
                    </ul>

                </div>
            </div>

            <div class="h2" style="text-align: center">
                Дата і час
            </div>
            <div>
                <p>
                    В PHP є вбудований клас з назвою DateTime для допомоги вам коли потрібно прочитати, записати,
                    порівняти чи порахувати дату або час. В PHP є багато функцій, повязаних з датою та часом,
                    окрім DateTime, та клас пропонує хороший об’єктно-орієнтований інтерфейс для вирішення
                    більшості задач. Він може обробляти часові зони, та це за межами цього короткого вступу.
                </p>
                <p>
                    Щоб почати працювати з DateTime конвертуйте необроблену строку дати та часу в об’єкт з
                    допомогою фабричного методу <code>createFromFormat()</code> або виконайте
                    <code>new \DateTime</code>, щоб отримати теперішню дату та час. Використовуйте метод
                    <code>format()</code> для конвертації DateTime назад в строку для виводу.
                </p>
                <code>
                    &lt;?php<br>
                    $raw = '22. 11. 1968';<br>
                    $start = \DateTime::createFromFormat('d. m. Y', $raw);<br>
                    <br>
                    echo "Start date: " . $start->format('m/d/Y') . "\n";<br>
                </code>
                <p>
                    Обчислення з DateTime можливе з використанням класу DateInterval. DateTime містить методи
                    <code>add()</code> та <code>sub()</code>, котрі приймають DateInterval як аргумент.
                    Не пишіть код, котрий очікує однакове число секунд кожного дня, перевід годинника та зміна
                    часових поясів знищать це припущення. Використовуйте замість цього інтервали дат.
                    Для розрахунку різниці між датами використовуйте метод <code>diff()</code>.
                    Він поверне новий DateInterval, котрий дуже легко відобразити.
                </p>
                <code>
                    &lt;?php<br>
                    // створіть копію $start та добавте 1 місяць і 6 днів<br>
                    $end = clone $start;<br>
                    $end->add(new \DateInterval('P1M6D'));<br>
                    <br>
                    $diff = $end->diff($start);<br>
                    echo "Difference: " . $diff->format('%m month, %d days (total: %a days)') . "\n";<br>
                    // Різниця: 1 місяць, 6 днів (всього: 37 днів)<br>
                </code>
                <p>
                    З обєктами DateTime ви можете використовувати стандартні порівняння:
                </p>
                <code>
                    &lt;?php<br>
                    if($start < $end) {<br>
                        echo "Start is before end!\n";<br>
                    }
                </code>
                <p>
                    Останій приклад для демонстрації класу DatePeriod, що використовується для ітерації повторюваних
                    подій. Він може приймати два об’єкти DateTime, початок і кінець, та інтервал для котрого він
                    поверне всі події між об’єктами.
                </p>
                <code>
                    &lt;?php<br>
                    // вивід всіх четвергів між $start та $end<br>
                    $periodInterval = \DateInterval::createFromDateString('first thursday');<br>
                    $periodIterator = new \DatePeriod($start, $periodInterval, $end,
                    \DatePeriod::EXCLUDE_START_DATE);<br>
                    foreach($periodIterator as $date)<br>
                    {<br>
                        // вивід кожної дати в періоді<br>
                        echo $date->format('m/d/Y') . " ";<br>
                    }
                </code>
                <ul>
                    <li>
                        <a href="http://www.php.net/manual/book.datetime.php">
                            Читати про DateTime
                        </a>
                    </li>
                    <li>
                        <a href="http://www.php.net/manual/function.date.php">
                            Читати про форматування дати
                        </a>(прийнятий варіант формату строки дати)
                    </li>
                </ul>
            </div>

            <div class="h2" style="text-align: center">
                Дизайни проектування
            </div>
            <div>
                <p>
                    Коли ви будуєте ваші додатки буде корисним використовувати загальноприйняті шаблони у вашому
                    коді та шаблони для загальної структури вашого проекту. Використовувати прийняті шаблони корисно,
                    тому що це спрощує управліня кодом, а також дозволяє іншим розробникам швидко зрозуміти як все
                    працює.
                </p>
                <p>
                    Якщо ви використовуєте фреймворк, то більшість високорівневого коду і структура проекту буде
                    базуватися на цьому фреймворку, тож велика кількість рішень відносно шаблону зроблена за вас.
                    Та все ж від вас залежить вибір кращих шаблонів для наслідування в коді, котрий ви будуєте
                    поверх фреймворку. Якщо з іншої сторони ви не використовуєте фреймворк для побудови своїх
                    додатків тоді вам потрібно знайти шаблони, котрі якнайкраще відповідають типу і розміру додатку,
                    що ви будуєте.
                </p>
                <ul>
                    <li>
                        Продовжити читати про
                        <a href="http://iflista.github.io/pages/Design-Patterns.html">
                            Шаблони проектування
                        </a>
                    </li>
                </ul>
            </div>

        </div>

        <div class="h1" style="text-align: center">
            Бази даних
        </div>
        <div>
            <p>
                Часто ваш PHP код буде використовувати базу даних для збереження інформації.
                У вас є кілька варіантів для підєднання та взаємодії з базою даних.
                Рекомендованим варіантом до <i>PHP 5.1.0</i> було використання рідних драйверів, таких як
                <a href="http://uk.php.net/mysql">mysql</a>,
                <a href="http://uk.php.net/mysqli">mysqli</a>,
                <a href="http://uk.php.net/pgsql">pgsql</a>, тощо.
            </p>
            <p>
                Рідні драйвери чудові, якщо ви використовуєте ОДНУ базу даних в вашому додатку, та якщо, для прикладу,
                ви використовуєте MySQL та трошки MSSQL, або вам потрібно підключитися до бази даних Oracle,
                тоді ви не зможете використовувати ті ж драйвери. Вам буде потрібно вивчити нове API для кожної
                бази даних — і це може бути нерозумно.
            </p>
            <p>
                В якості додаткової замітки про рідні драйвери, розширення MySQL для PHP більше не знаходиться в
                активній розробці і його офіційним статусом від PHP 5.4.0 являється “Застаріло через довгий час
                використання”. Це означає він буде видалений на протязі наступних кількох релізів, отож в PHP 5.6
                (або у всьому, що вийде після PHP 5.5) воно може пропасти. Якщо ви використовуєте
                <code>mysql_connect()</code> та <code>mysql_query()</code> у свому додатку, тоді вам прийдеться
                зіткнутися з переписуванням коду, отож найкращим варіантом буде замінити mysql використанням
                mysqli або PDO у своїх додатках під час вашого процесу розробки, отож би не стикнетеся з неробочим
                додатком потім. <i>Якщо ви починаєте з нуля тоді відмовтеся повністю від використання розширення mysql:
                    використовуйте <a href="http://uk.php.net/mysqli">Розширення MySQLi</a>, або PDO</i>.
            </p>
            <ul>
                <li>
                    <a href="http://php.net/manual/en/mysqlinfo.api.choosing.php">
                        PHP: Вибір API для MySQL
                    </a>
                </li>
            </ul>

            <div class="h2" style="text-align: center">
                PDO
            </div>
            <div>
                <p>
                    PDO це абстрактна бібліотека для підключення до бази даних — вбудована в PHP з версії 5.1.0
                    — вона забезпечує спільний інтерфейс для спілкування з великою кількістю різних баз даних.
                    PDO не буде перекладати ваші SQL запити чи емулювати відсутні можливості; він чисто для
                    підключення до різноманітних типів баз даних через одне і те ж API.
                </p>
                <p>
                    Більш важливо, що <code>PDO</code> дозволяє вам безпечно вводити дані користувача (напр. IDs)
                    в ваші SQL запити без хвилювання щодо атак на SQL введення. Це можливо,
                    завдяки використанню PDO виразів і звязування параметрів.
                </p>
                <p>
                    Припустиму, що PHP отримує числовий ID в якості параметру запиту.
                    Цей ID повинен бути використаний для отримання запису користувача з бази даних.
                    Ось <b>неправильний</b> шлях це зробити:
                </p>
                <code>
                    &lt;?php<br>
                    $pdo = new PDO('sqlite:users.db');<br>
                    $pdo->query("SELECT name FROM users WHERE id = " . $_GET['id']); // <-- NO!
                </code>
                <p>
                    Це жахливий код. Ви вставляєте сирі параметри в SQL запит. Це приведе до взламу вашого коду в
                    секунди. Замість цього ви повинні очистити ввід ID використовуючи звязування параметрів PDO.
                </p>
                <code>
                    &lt;?php<br>
                    $pdo = new PDO('sqlite:users.db');<br>
                    $stmt = $pdo->prepare('SELECT name FROM users WHERE id = :id');<br>
                    $stmt->bindParam(':id', $_GET['id'], PDO::PARAM_INT); //<-- Automatically sanitized by PDO<br>
                    $stmt->execute();
                </code>
                <p>
                    Ось правильний код. Він використовує звязаний параметр в виразі PDO. Це дозволяє уникнути
                    некоректного користувацького вводу ID перед тим як передати запит в базу даних, запобігаючи
                    потенційні атаки типу SQL ін’єкцій.
                </p>
                <ul>
                    <li>
                        <a href="http://www.php.net/manual/en/book.pdo.php">
                            Детальніше про PDO
                        </a>
                    </li>
                </ul>
            </div>

            <div class="h2" style="text-align: center">
                Рівні абстракції
            </div>
            <div>
                <p>
                    Багато фреймворків надають свій власний рівень абстракції, котрий може або не може сидіти поверх
                    PDO. Вони часто будуть емулювати можливості для одної системи бази даних, котрі не має інша,
                    повертаючи ваші запити в PHP методи, даючи вам фактичну абстракцію бази даних. Це звісно,
                    добавить деякі накладні витрати, та якщо ви будуєте портативний додаток, якому потрібно
                    працювати з MySQL, PostgreSQL та SQLite тоді мінімальними накладними витратами можна знехтувати
                    задля чистоти коду.
                </p>
                <p>
                    Деякі рівні абстракції були побудовані з використанням PSR-0 стандарту простору імен,
                    отож можуть бути встановлені в будь який додаток:
                </p>
                <ul>
                    <li>
                        <a href="http://www.doctrine-project.org/projects/dbal.html">
                            Doctrine2 DBAL
                        </a>
                    </li>
                    <li>
                        <a href="http://packages.zendframework.com/docs/latest/manual/en/index.html#zend-db">
                            ZF2 Db
                        </a>
                    </li>
                    <li>
                        <a href="http://framework.zend.com/manual/en/zend.db.html">
                            ZF1 Db
                        </a>
                    </li>
                </ul>

            </div>
        </div>

        <div class="h1" style="text-align: center">
            Безпека
        </div>
        <div>
            <div class="h2" style="text-align: center">
                Безпека веб додатків
            </div>
            <div>
                <p>
                    Є погані люди, котрі готові і хочуть зламати ваші веб додатки. Важливо, щоб ви прийняли
                    необхідні заходи безпеки, щоб укріпити безпеку вашого додатку. На щастя, хороші люди з
                    <a href="https://www.owasp.org/">The Open Web Application Security Project</a> (OWASP)
                    склали повний перелік відомих проблем безпеки і методів захисту від них.
                    Це повинно бути прочитано кожним розробником, котрий переймається безпекою.
                </p>
                <ul>
                    <li>
                        <a href="https://www.owasp.org/index.php/Guide_Table_of_Contents">
                            Читати керівництво з безпеки OWASP
                        </a>
                    </li>
                </ul>
            </div>

            <div class="h2" style="text-align: center">
                Хешування паролю з Bcrypt
            </div>
            <div>
                <p>
                    В кінці кінців кожен будує PHP додаток, котрий базується на авторизації користувача.
                    Імена користувачів і (хешовані) паролі зберігаються в базі даних і пізніше використовуються
                    для авторизації користувачів під час входу.
                </p>
                <p>
                    Важливо, щоб ви правильно <i>хешували</i> паролі, котрі зберігаються в базі даних.
                    Якщо паролі не хешовані і ваша база даних взламана або до неї отриманий несанкціонований
                    доступ третьої сторони, всі користувацькі облікові записи будуть під загрозою.
                </p>
                <p>
                    <b>Хешовані паролі з Bcrypt.</b> Це дуже просто, і (для всіх запитів та цілей) Bcrypt
                    робить неможливим для кого б це не було, відтворити текстову версію паролю,
                    якщо база даних буде компрометована.
                </p>
                <p>
                    Є кілька бібліотек Bcrypt для PHP, котрі ви можете використовувати.
                </p>
                <ul>
                    <li>
                        <a href="http://codahale.com/how-to-safely-store-a-password/">
                            Читати “Як безпечно зберігати пароль” від Coda Hale
                        </a>
                    </li>
                    <li>
                        <a href="http://www.openwall.com/phpass/">
                            Використовуйте Bcrypt з PHPass
                        </a>
                    </li>
                </ul>
            </div>

            <div class="h2" style="text-align: center">
                Фільтрування даних
            </div>
            <div>
                <p>
                    Ніколи не довіряйте користувацькому вводу, котрий передається вашому PHP коду.
                    Завжди перевіряйте і очищайте користувацький ввід, перед його використанням в коді.
                    Функції <code>filter_var</code> і <code>filter_input</code> можуть очистити текст,
                    а також перевірити відповідність вводу певним форматам тексту (наприклад адрес електронної пошти).
                </p>
                <p>
                    Користувацький ввід може бути будь яким: <code>$_GET</code> і <code>S_POST</code> дані внесені
                    в форму, деякі значення в суперглобальній змінній <code>$_SERVER</code> і тіло HTTP запиту з
                    допомогою <code>fopen('php://input, ‘r’)`</code>. Запам’ятайте, що користувацький ввід
                    не обмежується лише даними форми, відправленої користувачем. Файли котрі відправляються і
                    завантажуються, значення сесій, дані cookie і дані сторонніх веб сервісів, також
                    прирівнюються до користувацького вводу.
                </p>
                <p>
                    Хоча користувацькі дані можуть бути без проблем збережені, скомбіновані і до них може бути
                    отриманий доступ пізніше, та він все ще являється користувацьким вводом. Кожного разу, коли ви
                    обробляєте, об’єднуєте чи підключаєте дані в ваш код, спитайте себе чи відфільтровані ці дані і
                    чи можна їм довіряти.
                </p>
                <p>
                    Дані можуть бути <i>відфільтровані</i> по-різному, в залежності від їх призначення. Наприклад,
                    коли нефільтрований користувацький ввід передається в HTML код сторінки, він може виконати HTML
                    і JavaScript на вашому сайті! Це відомо, як Cross-Site-Scripting (XSS) і може бути дуже
                    небезпечним видом атаки. Один із способів уникнути XSS, полягає в валідації вводу від всіх HTML
                    тегів (їх видаленням чи заміною на HTML символи).
                </p>
                <p>
                    Інший приклад - це передача даних для виконання командною строкою. Це може бути дуже небезпечно
                    (і, як правило, це погана ідея), але ви можете використати вбудовану функцію
                    <code>escapeshellarg</code> для валідації аргументів командної строки.
                </p>
                <p>
                    Останній приклад приймає користувацький ввід, щоб визначити, який файл завантажувати з
                    файлової системи. Це може бути використано, для зміни імені файлу, на шлях файлу.
                    Вам потрібно забрати “/”, “../.”
                    <a href="http://php.net/manual/en/security.filesystem.nullbytes.php">нульові байти</a>
                    або інші символи із шляху файлу так, щоб він не міг завантажувати приховані,
                    непублічні або конфіденційні файли.
                </p>
                <ul>
                    <li>
                        <a href="http://www.php.net/manual/en/book.filter.php">
                            Читати про фільтрацію даних
                        </a>
                    </li>
                    <li>
                        <a href="http://php.net/manual/en/function.filter-var.php">
                            Читати про <code>filter_var</code>
                        </a>
                    </li>
                    <li>
                        <a href="http://www.php.net/manual/en/function.filter-input.php">
                            Читати про <code>filter_input</code>
                        </a>
                    </li>
                    <li>
                        <a href="http://php.net/manual/en/security.filesystem.nullbytes.php">
                            Читати про обробку нульових байтів
                        </a>
                    </li>
                </ul>

                <div class="h3" style="text-align: center">
                    Очистка
                </div>
                <div>
                    <p>
                        Очистка видаляє (або екранує) невірні або небезпечні символи із користувацького вводу.
                    </p>
                    <p>
                        Для прикладу, вам потрібно нормалізувати користувацький ввід, перед підключенням вводу в
                        HTML або його вставкою в сирий запит SQL. Коли ви використовуєте звязані параметри з
                        <a href="http://iflista.github.io/php-the-right-way/#databases">PDO</a>
                        вони будуть очищати ввід за вас.
                    </p>
                    <p>
                        Інколи потрібно дозволити деякі небезпечні HTML теги у вводі, включаючи його в HTML сторінку.
                        Це дуже важко зробити і уникнути інших тегів, та це можна зробити, використовуючи
                        обмежене форматування, як наприклад Markdown або BBCode тим не менше бібліотеки з білим
                        переліком, як <a href="http://htmlpurifier.org/">HTML Purifier</a> існують саме для цього.
                    </p>
                    <p>
                        <a href="http://www.php.net/manual/en/filter.filters.sanitize.php">
                            Проглянути очищуючі фільтри
                        </a>
                    </p>
                </div>

                <div class="h3" style="text-align: center">
                    Валідація
                </div>
                <div>
                    <p>
                        Валідація гарантує, що користувацький ввід, являється тим, що ви очікуєте. Наприклад,
                        ви можете валідувати: адрес електронної пошти, номер телефону або вік при обробці
                        запиту реєстрації.
                    </p>
                    <p>
                        <a href="http://www.php.net/manual/en/filter.filters.validate.php">
                            Проглянути фільтри валідації
                        </a>
                    </p>
                </div>
            </div>

            <div class="h2" style="text-align: center">
                Файли конфігурації
            </div>
            <div>
                <p>
                    Коли ви створюєте файли конфігурації для ваших додатків, кращі практики рекомендують
                    використання одного з наступних способів:
                </p>
                <ul>
                    <li>
                        Рекомендується зберігати вашу конфігураційну інформацію, там, де до неї не може бути
                        отриманий доступ напряму і через файлову систему.
                    </li>
                    <li>
                        Якщо ви повинні зберігати ваші конфігураційні файли в кореневому каталозі, іменуйте файл з
                        розширенням <code>.php</code>. Це гарантує, що, якщо до скрипту звернуться напряму,
                        він не буде виведений як звичайний текст.
                    </li>
                    <li>
                        Інформація в файлах конфігурації повинна бути відповідно захищена, або через шифрування,
                        або відповідними системними правами групи/користувача файлу.
                    </li>
                </ul>
            </div>

            <div class="h2" style="text-align: center">
                Використання глобальних змінних (Register_Globals)
            </div>
            <div></div>

        </div>

        <div class="row-fluid" style="text-align: center">
            <div class="span12">
                <div class="row-fluid">

                    <div class="span6 btn btn-link">
                        <a href="oop.php">
                            <button type="button">
                                <span class="glyphicon glyphicon-arrow-left"></span> Попередня сторінка
                            </button>
                        </a>
                    </div>

                    <div class="span6 btn btn-link">
                        <a href="psr0.php">
                            <button type="button" >
                                Наступна сторінка <span class="glyphicon glyphicon-arrow-right"></span>
                            </button>
                        </a>
                    </div>

                </div>
            </div>
        </div>

    </div>

<?php include_once("footer.php");